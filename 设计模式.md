###设计模式-组合模式

####定义
组合模式是将对象组合成树状结构以表示部分和整体的层次结构，让用户对单个对象和组合对象使用具有一致性。

####系统框架
iOS系统框架中UIView使用的是组合模式，通过addSubView方法，将其他对象组合到uiview上，形成树形结构。文件夹也是组合模式的应用。

####使用场景
* 表示对象整体和部分结构的时候
* 从一个整体中能够独立出部分模块或功能

####角色划分
* 抽象根节点，对组合对象进行抽象
* 具体子节点
* 叶子节点，没有子节点

####示例
testswft_组合模式

###设计模式-享元模式

####定义
享元模式，顾名思义就是元素共享，使用共享对象减少内存分配，让相同业务逻辑访问同一对象，而不是每次访问都创建新对象。共享对象放到缓冲池中，业务请求时先去缓存池中找对象对象，没有才会创建。例如下载10000张图片，如果开10000个线程，会很占很多资源，iOS系统会创建线程池，允许最大线程数据如果是30个线程，创建的线程会放到线程池中，当需要下载图片时从线程池中取对象。

####使用场景
* 系统中存在大量的相似对象（相同）。例如：线程、链接、消息机制（安卓里面Handler：Message消息共享）
* 需要缓冲池场景

####角色划分
* 享元对象抽象接口
* 具体享元对象
* 享元工厂，负责管理享元对象池和创建享元对象

####示例
testswft_享元模式，实例场景是根据用户乘车区间打印车票信息，通过乘车区间创建一个车票对象，并放到缓冲区中，假如北京-上海这个区间的车票信息有10000个人访问，那这10000个人访问的都是同一对象。

###设计模式-解析器模式

####定义
针对特定语法表达式的一个句子，定义一个解析器来解析语句。

####使用场景
* 解析语句中的表达式，获取每一个元素，形成语法树。例如："a + b + c + d - e"表达式
* 在某些特定的领域出现不断重复的问题时，可以将该领域的问题转化为一种语法规则下的语句，然后构建解析器来解释该语句。例如：大小写转换、数字转字符串、字符串转数字、阿拉伯数字转中文等等...这个转换过程就是一个重复不断问题。

####角色划分
* 抽象表达式
* 终结符表达式
* 非终结符表达式
* 上下文
* 客户端

####示例
解析表达式"1 + 2 + 3 + 4 +5"，首先对表达式中的元素进行抽象，1、2、3、4、5属于终结符，需要根据其前后的运算符进行对应的运算；+属于非终结表达式，配合终结表达式进行运算。

###设计模式-桥接模式

####定义
将抽象部分和实心部分进行分离，使他们之间都可以独立进行变化

####解决问题
解决类层级结构爆炸问题

####使用场景
* 开发中类层次结构负责，
* 一个类存在两个独立维度，并且这两个维度都需要进行扩展。
* 对于不要的API之间也可以进行桥接

####角色划分
* 抽象部分
* 优化抽象部分，抽象子类
* 实现部分，接口、抽象类
* 实现部分，具体的类
* 客户端

####示例

###外观模式

####定义
* 要求子系统的外部和内部通讯必须通过一个统一的接口对象进行
* 外观模式提供一个高层次接口，使子系统更容易使用

####使用场景
* 为负责系统提供一个简单接口
* 在构建一个层次结构的子系统时，外观模式定义子系统的每一层入口点。如果子系统直接相互依赖，可以通过外观模式减低他们直接的耦合。 

####角色划分
* 系统对外统一接口
* 子系统接口

####原理示例
电脑：拍照功能，音乐功能，使用外观模式，不用关心内部实现，只需使用外层接口

###中介者模式

####定义
包装一系列对象相互作用方式，使得这些对象不必相互明显作用。从而降低耦合度。当某些对象之间的作用发送改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立变化。中介者模式将多对多的相互作用转换成一对多的相互作用。中介者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。

####应用场景
当对象之间的交互操作很多且每个对象的行为操作都彼此依赖时，为防止在修改一个对象的行为时，同时设计修改很多其他对象的行为，可采用中介者模式来解决耦合问题。

####角色
* 抽象中介者，定义了同事对象到中介者对象的接口，一般是抽象类或接口
* 具体中介者：继承了抽象中介者，实现具体的业务方法。实现父类定义方法，从具体的同事对象接收消息，同时也会向同事对象发送消息
* 抽象同事：定义了中介者对象接口，只知道中介者，而不知道其他同事
* 具体同事：继承了同事抽象类，每一个具体的同事类都知道本身范围之内行为，而不知道它之外的行为

####案例
电脑：CPU 显卡 内存 IO设备 主板
中介者 ：主板
同事：CPU 显卡 内存 IO设备

###备忘录模式

####概念
* 行为设计模式
* 用于保存对象当前状态，并且以后可以再次回复到此状态，后悔药
* 需要保证被保存的对象状态不能被对象从外部访问，为了保护好被保存的这些对象状态的完整性以及内部实现不向外暴露

####定义
在不破坏封闭的前提下，捕获一个对象的内部状态，并且在对象之外保存这个对象的状态，这样以后就可以将改对象恢复到原来的状态。

####使用场景
* 需要保存对象在某一时刻的状态或部分状态
* 如果用一个接口或协议来让其他对象得到这些状态，将会暴露对象实现细节并且破坏对象封装性，我们不希望外界直接访问对象内部状态，通过中间对象进行间接访问内部对象。

####角色划分
* originator：负责创建备忘录，可以记录 恢复自身内部状态
* memo：备忘录，用于存储originator内部状态，并且可以防止originator以外对象访问memo对象
* careteker:负责存储备忘录(很少定义)

####原理示例
玩游戏：升级 降级

